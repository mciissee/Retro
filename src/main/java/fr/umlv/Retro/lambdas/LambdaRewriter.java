package fr.umlv.Retro.lambdas;

import java.util.Arrays;
import java.util.Objects;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Handle;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;

import fr.umlv.Retro.Retro;
import fr.umlv.Retro.models.ClassInfo;
import fr.umlv.Retro.models.MethodInfo;
import fr.umlv.Retro.utils.InstUtils;
import fr.umlv.Retro.utils.VersionUtils;

/**
 * Rewrites lambda implemented with an InvokeDynamic call to an inner class.
 */
class LambdaRewriter implements Opcodes {

	private static int methodRefs;

	private final Retro app;
	private final ClassInfo ci;
	private final MethodInfo mi;
	private final LambdaDetector mv;
	private final ClassWriter cw;

	public LambdaRewriter(LambdaDetector mv,  Retro app, ClassInfo ci, MethodInfo mi) {
		this.mv = Objects.requireNonNull(mv);
		this.ci = Objects.requireNonNull(ci);
		this.mi = Objects.requireNonNull(mi);
		this.app = Objects.requireNonNull(app);
		this.cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
	}

	/**
	 * Rewrites an invoke dynamic instructor representing a lambda to an inner class.
	 * @param name the method's name.
	 * @param descriptor the method's descriptor (see Type).
	 * @param bsm the bootstrap method.
	 * @param bsmArgs the bootstrap method constant arguments.
	 */
	public void rewrite(String name, String descriptor, Handle bsm, Object... bsmArgs) {
		Objects.requireNonNull(name);
		Objects.requireNonNull(descriptor);
		Objects.requireNonNull(bsm);
		Objects.requireNonNull(bsmArgs);

		var lambda = (Handle)bsmArgs[1];
		var clazz = createClassName(lambda);
		var captures = Type.getArgumentTypes(descriptor);
		var constructor = createConstructor(captures);
		var interfacedesco = bsmArgs[0].toString(); // descriptor without generic type informations
		var interfacedescg = bsmArgs[2].toString(); // descriptor with generic type informations

		visitClass(clazz, descriptor);
		visitFields(captures);
		visitConstructor(clazz, constructor, captures);
		visitMethodImplements(clazz, name, lambda, interfacedescg, captures);
		visitMethodOverload(clazz, name, interfacedesco, interfacedescg);
		visitCreateInstruction(clazz, constructor, captures);

		app.write(ci.path(), clazz, cw.toByteArray());
	}


	/**
	 * Writes bytecode instructions to declare the class heading.
	 * @param name class name.
	 * @param descriptor class descriptor.
	 */
	private void visitClass(String name, String descriptor) {
		var version = VersionUtils.toBytecode(app.target());
		var interfaces =  new String[] {Type.getReturnType(descriptor).getInternalName()};
		cw.visit(version, ACC_SUPER, name, null, "java/lang/Object", interfaces);
		cw.visitSource(ci.className() + ".java", null);
		cw.visitOuterClass(ci.className(), mi.methodName(), mi.descriptor());
		cw.visitInnerClass(name, ci.className(), name, 0);
	}

	/**
	 * Writes bytecode instructions to declare fields of the inner class.
	 * @param types field types (type of the variables captured by the lambda function).
	 */

	private void visitFields(Type[] types) {
		IntStream.range(0, types.length).forEach(i -> {
			cw.visitField(ACC_FINAL | ACC_SYNTHETIC, "f$" + i, types[i].toString(), null, null).visitEnd();
		});;
	}

	/**
	 * Writes bytecode instructions to declare the constructor of the inner class.
	 * @param clazz name of the constructor
	 * @param descriptor descriptor of the constructor
	 * @param params type of the constructor's parameters.
	 */
	private void visitConstructor(String clazz, String descriptor, Type[] params) {
		var mv = cw.visitMethod(ACC_PUBLIC, "<init>", descriptor, null, null);
		mv.visitCode();
	
		// super()
		mv.visitVarInsn(ALOAD, 0);
		mv.visitMethodInsn(INVOKESPECIAL, "java/lang/Object", "<init>", "()V", false);
		
		// this.f$[i] = params[i]
		for (int i = 0; i < params.length; i++) {
			mv.visitVarInsn(ALOAD, 0);
			InstUtils.load(mv, params[i], i + 1);
			mv.visitFieldInsn(PUTFIELD, clazz, "f$" + i, params[i].toString());
		}

		mv.visitInsn(RETURN);
		mv.visitMaxs(1, 1);
		mv.visitEnd();
	}

	
	/**
	 * Writes bytecode instructions to implement the method from the functional interface of the lambda with generic type informations.
	 * @param clazz the name of the anonymous class.
	 * @param name the name of the method to implement from the functional interface.
	 * @param lambda reference to the method generated by the invoke dynamic instruction.
	 * @param interfacedescg descriptor of the functional interface method (with generic types).
	 * @param captures type of the variables captured by the lambda function.
	 */
	private void visitMethodImplements(String clazz, String name, Handle lambda, String interfacedescg, Type[] captures) {
		var mv = cw.visitMethod(ACC_PUBLIC, name, interfacedescg, null, null);
		mv.visitCode();
		
		// push the captures fields on the stack.
		for (int i = 0; i < captures.length; i++) {
			mv.visitVarInsn(ALOAD, 0);
			mv.visitFieldInsn(GETFIELD, clazz, "f$" + i, captures[i].toString());
		}
	
		// push the arguments of the method
		var params = parameters(lambda, captures);
		var interfaceargsg = Type.getArgumentTypes(interfacedescg);
		for (int i = 0; i < interfaceargsg.length; i++) {
			InstUtils.load(mv, interfaceargsg[i], i + 1);
			if (!interfaceargsg[i].equals(params[i])) {
				InstUtils.cast(mv, interfaceargsg[i], params[i]);
			}
		}
		
		// call the generated lambda method
		var opcode = lambda.getTag() == H_INVOKESTATIC ? INVOKESTATIC : INVOKEVIRTUAL;
		mv.visitMethodInsn(opcode, lambda.getOwner(), createMethodAccessor(lambda), lambda.getDesc(), false);
		
		var r1 = Type.getReturnType(lambda.getDesc());
		var r2 = Type.getReturnType(interfacedescg);
		if (!r1.equals(r2)) {
			InstUtils.cast(mv, r1, r2);	
		}
		InstUtils.ret(mv, r2);
		mv.visitMaxs(1, 1);
		mv.visitEnd();
	}

	
	/**
	 * Writes bytecode instructions to implement the method from the functional interface of the lambda without generic type informations.
	 * @param clazz the name of the anonymous class.
	 * @param name the name of the method to implement from the functional interface.
	 * @param interfacedesco descriptor of the functional interface method (without generic types erasure).
	 * @param interfacedescg descriptor of the functional interface method (with generic types).
	 */
	private void visitMethodOverload(String clazz, String name, String interfacedesco, String interfacedescg) {
		if (!interfacedesco.equals(interfacedescg)) {
			var mv = cw.visitMethod(ACC_PUBLIC | ACC_BRIDGE | ACC_SYNTHETIC, name, interfacedesco, null, null);
			mv.visitCode();
			mv.visitVarInsn(ALOAD, 0);
			
			var interfaceargsg = Type.getArgumentTypes(interfacedescg);
			var params = Type.getArgumentTypes(interfacedesco);
			for (int i = 0; i < params.length; i++) {
				InstUtils.load(mv, params[i], i + 1);
				mv.visitTypeInsn(CHECKCAST, interfaceargsg[i].getInternalName());
			}
			mv.visitMethodInsn(INVOKEVIRTUAL, clazz, name, interfacedescg, false);

			InstUtils.ret(mv, Type.getReturnType(interfacedesco));
			mv.visitMaxs(1, 1);
			mv.visitEnd();
		}
	}

	
	/**
	 * Writes bytecode instructions to replace lambda invoke dynamic instruction with a creation of the 
	 * inner class.
	 * @param clazz the class name
	 * @param constructor descriptor of the inner class constructor?
	 * @param arguments type of the constructor's arguments.
	 */
	private void visitCreateInstruction(String clazz, String constructor, Type[] arguments) {
		var args = new Integer[arguments.length];
		for (var i = arguments.length - 1; i >= 0; i--) {
			var arg = arguments[i];
			args[i] = mv.newLocal(arg);
			InstUtils.store(mv, arg, args[i]);
		}
		mv.visitTypeInsn(NEW, clazz);
		mv.visitInsn(DUP);
		for (var i = 0; i < arguments.length; i++) {
			InstUtils.load(mv, arguments[i], args[i]);
		}
		mv.visitMethodInsn(INVOKESPECIAL, clazz, "<init>", constructor, false);
	}

	private String createClassName(Handle bsm) {
		var clazz = String.format("%s$%s", bsm.getOwner(), bsm.getName());
		if (!bsm.getName().contains("$")) { // method reference
			clazz = String.format("%s$%s$Ref%d", ci.className(), bsm.getName(), ++methodRefs);
		}
		return clazz.replace("/", "$");
	}

	private String createConstructor(Type[] params) {
		return Arrays.stream(params)
				.map(e -> e.toString())
				.collect(Collectors.joining("", "(", ")V"));
	}

	
	/**
	 * Since method generated with invoke dynamic for the lambda is private
	 * this method creates new one with package level visibility that call the private method.
	 * in this way the method can be called from the inner class.
	 * 
	 * @param lambda reference to the method generated by the invoke dynamic instruction.
	 * @return name of the method to call.
	 */
	private String createMethodAccessor(Handle lambda) {
		var owner = lambda.getOwner();
		if (!owner.equals(ci.className())) { // skip method references like Integer::sum
			return lambda.getName();
		}

		var cv = ci.visitor();
		var desc = lambda.getDesc();
		var name = String.format("access$%s", lambda.getName());
		var isStatic = lambda.getTag() == H_INVOKESTATIC;
	
		var mv = cv.visitMethod((isStatic ? ACC_STATIC : 0) + ACC_SYNTHETIC, name, desc, null, null);
		mv.visitCode();	
	
		var types = Type.getArgumentTypes(desc);
		var i = 0;
		if (!isStatic) {
			mv.visitVarInsn(ALOAD, 0);
			i++;
		}

		for (var type : types) {
			InstUtils.load(mv, type, i);
			i += type.getSize();
		}

		mv.visitMethodInsn(isStatic ? INVOKESTATIC : INVOKEVIRTUAL, lambda.getOwner(), lambda.getName(), desc, false);

		InstUtils.ret(mv, Type.getReturnType(desc));
		mv.visitMaxs(1, 1);
		mv.visitEnd();
	
		return name;
	}


	private Type[] parameters(Handle method, Type[] captures) {
		var params = Type.getArgumentTypes(method.getDesc());
		var skip = params.length == captures.length ? 0 : captures.length;
		return Arrays
				.stream(params)
				.skip(skip)
				.toArray(Type[]::new);
	}

}
